/~
	ADL, Javascript implementation for the Abstract Definition Language
	Copyright 2009 by Christophe VG & TheSoftwareFactory

	see LICENSE file and http://thesoftwarefactory.be/wiki/ADL for
	information how you can use ADL

	ADL Format: everything is a construct:
	type name : super +modifier := value {
	  <constructs>	    
	}

	This parser returns an AST of constructs, aka ACT ;-)
~/
	
[*

// top-level ADL namespace
var ADL = {};

ADL.Boolean = Class.extend( {
  value : null,

  init: function( value ) {
    this.value = value == "true" ? true : false;
  },

  toString: function() {
    return this.value ? "true" : "false";
  }
});

ADL.Integer = Class.extend( {
  value : null,

  init: function( value ) {
    this.value = value;
  },

  toString: function() {
    return this.value;
  }
});

ADL.String = Class.extend( {
  value : null,

  init: function( value ) {
    this.value = value;
  },

  toString: function() {
    return '"' + this.value + '"';
  }
});

ADL.Annotation = Class.extend( {
  data : null,

  init: function( data ) {
    this.data = data;
  },

  toString: function() {
    return "[@" + this.data + "]";
  }
});

ADL.Multiplicity = Class.extend( {
  low : null,
  high : null,

  init: function( low, high ) {
    this.low = low;
    this.high = high;
  },

  toString: function() {
    return "[" + this.low + ( this.high ? ".." + this.high : "" ) + "]";
  }
});

ADL.Reference = Class.extend( {
  constructName : null,
  multiplicity : null,

  init: function( constructName, multiplicity ) {
    this.constructName = constructName;
    this.multiplicity = multiplicity;
  },

  toString: function() {
    return this.constructName + 
    ( this.multiplicity ? this.multiplicity.toString() : "" );
  }
});

ADL.Modifier = Class.extend( {
  key : null,
  value : null,

  init: function( key, value ) {
    this.key = key;
    this.value = value;
  },

  toString: function() {
    return "+" + this.key + 
    ( this.value ? "=" + this.value.toString() : "" );
  }
});

ADL.Construct = Class.extend( {
  init: function( type, name ) {
    this.annotation = null;
    this.type = type;
    this.name = name;
    this.value = null;
    this.supers    = new Array();
    this.modifiers = new Hash();
    this.children  = new Array();
  },

  toString: function(ident) {
    ident = ident || "";

    var modifiers = new Array();
    this.modifiers.iterate(function(key, value) { 
      modifiers.push( value.toString() ); 
    });

    var children = new Array();
    this.children.iterate( function(item) { 
      children.push( item.toString("  " + ident) ); 
    });

    return ( this.annotation ? 
      ident + this.annotation.toString() + "\n" : "" ) 
      + ident + this.type 
      + " " + this.name
      + ( this.supers.length > 0 ? " : " + this.supers.join(" : ") : "" )
      + ( modifiers.length  > 0 ? " "   + modifiers.join(" ") : "" )
      + ( this.value ? " = " + this.value : "" )
      + ( children.length > 0 ? 
        " {" + "\n" + children.join( "\n") + "\n" + ident + "}" : ";" );
  },

  accept: function( visitor, data ) {
    return visitor.visit(this, data);
  },

  childrenAccept: function( visitor, data ) {
    this.children.iterate(function(child) { visitor.visit(child, data); } );
    return data;
  }
} );

ADL.include = function( file ) {
  var adl = new ProtoJS.Ajax().fetch( file.value + ".adl" );
  return new ADL.Parser().parse(adl).getChildren();
}

ADL.createConstruct = function( annotation, type, name, supers, 
                                modifiers, value, children )
{
  var c = new ADL.Construct( type, name )  ;
  if( annotation ) { c.annotation = annotation; }
  if( supers ) { c.supers = supers; }
  if( Object.isArray(modifiers) ) {
    modifiers.iterate(function(modifier) { 
      c.modifiers.set(modifier.key, modifier);
    } );
  }   
  if( value ) { c.value = value; }
  if( Object.isArray(children) ) { 
    c.children = children;
  }  
  return c; 
}

ADL.AST = Class.extend( {
  root : ADL.createConstruct( "", "root", "" ),
  init: function(top) {
    this.root.children = top;
  },
  getRoot: function() {
    return this.root;
  },
  getChildren: function() {
    return this.root.children;
  }
});

ADL.ast = null;

ADL.Parser = Class.extend( {
  parse: function( src ) {
    var error_cnt = 0;
    var error_off = new Array();
    var error_la  = new Array();

    ADL.ast = null;

    if( ( error_cnt = __##PREFIX##parse( src, error_off, error_la ) ) > 0 ) {
      var i;
      var errors = "";
      for( i = 0; i < error_cnt; i++ ) {
        errors += "Parse error: " + src.substr( error_off[i], 30 ) + 
        ". Expecting \"" + error_la[i].join() + "\n";
      }
      this.errors = errors;
      return null;
    }
    this.errors = "";
    return ADL.ast;
  }

});

function makeList() {
  var ar = new Array();
  if( arguments ) {
    for( var v=0; v<arguments.length; v++ ) {
      if( Object.isArray(arguments[v]) ) {
        for( var vv=0; vv<arguments[v].length; vv++ ) {
          if( arguments[v][vv] ) { 
            ar.push(arguments[v][vv]); 
          }
        }
      } else {
        if( arguments[v] ) { ar.push(arguments[v]); }
      }
    }
  }

  return ar;
}

*]

!	' |\t|\n|\r|\f|//[^\n]*\n|[^/]/\*[^\*]*\*(\*|[^\*/][^\*]*\*)*/'

	'true|false'			 Boolean
        [* %match = new ADL.Boolean( %match ); *]
	'[\+\-]?(0|[1-9][0-9]*)'	 Integer
        [* %match = new ADL.Integer( %match ); *]
	'"([^"])*"'			 String	
        [* %match = new ADL.String( %match.substr( 1, %match.length - 2 ) ); *]
	'\[@([^\]])*\]'			 Annotation	
        [* %match = new ADL.Annotation(%match.substr(2, %match.length - 3)); *]
        '\('
        '\)'
	'{'
	'}'
	'\['
	'\]'
	';'
	':'
	'::'
        '\.'
        ','

	'\+'
	'\-'
	'='
	'!='
	':='
        '\*'
        '/'
	'\|'
	'\.\.'
	'<'
	'>'

	'#include'			     IncludeDirective

    '[a-zA-Z_][a-zA-Z0-9_\.\-]*'         Identifier;

##

Program: Statements [* ADL.ast = new ADL.AST(%1); *];

Statements: Statements Statement  [* %% = makeList( %1, %2 ); *]
          |;
				
Statement: Construct
	 | Directive;
				
Construct: Annotations Modifiers Type Name Supers Modifiers Value Children
    [* %% = ADL.createConstruct( %1, %3, %4, %5, makeList( %2, %6) , %7, %8 ); *];

Directive: IncludeDirective String
    [* %% = ADL.include( %2 ); *];

Annotations: Annotation
           |;

Generics: Generics Generic [* %% = makeList( %1, %2 ); *];

Generic: '<' GenericArguments '>' [* %% = %1 + %2.join(",") + %3 *];

GenericArgument: Identifier;

GenericArguments: GenericArguments ',' GenericArgument 
                    [* %% = makeList( %1, %3 ) *] 
                | GenericArgument 
                    [* %% = makeList( %1 ) *]
                |; 

Name: Identifier | Identifier Generic [* %% = %1+%2 *];

Type: Identifier | Identifier Generic [* %% = %1+%2 *];

Supers: Supers Super [* %% = makeList( %1, %2 ); *]
      |;

Super: ':' Type Multiplicity [* %% = new ADL.Reference( %2, %3 ); *];

Multiplicity: '[' Integer ']'         [* %% = new ADL.Multiplicity( %2 );  *]
       | '[' Integer '..' Integer ']' [* %% = new ADL.Multiplicity( %2, %4 ); *]
       |;

Modifiers: Modifiers Modifier [* %% = makeList( %1, %2 ); *]
         |;

Modifier: '+' Identifier              [* %% = new ADL.Modifier( %2 );     *]
        | '+' Identifier '=' Constant [* %% = new ADL.Modifier( %2, %4 ); *];

Value: ':=' Constant [* %% = %2 *] 
     |;

Constant: String | Integer | Boolean;

Children: '{' Statements '}' [* %% = %2;   *]
        | ';'                [* %% = null; *];
